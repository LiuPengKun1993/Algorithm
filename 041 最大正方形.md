# 最大正方形

> 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。


示例:

```
输入：
matrix = [["1","0","1","0","0"],
          ["1","0","1","1","1"],
          ["1","1","1","1","1"],
          ["1","0","0","1","0"]]

输出：4
```



#### 解题思路：

此题最直接的解法是暴力解法，首先遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。

这里使用的是动态规划方法。可以使用动态规划降低时间复杂度。我们用 dp(i,j) 表示以 (i,j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。

那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：

- 如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；
- 如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：

`dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1`




```
func maximalSquare(_ matrix: [[String]]) -> Int {
    var maxSide = 0
    if matrix.count == 0 || matrix[0].count == 0 {
        return maxSide
    }
    
    let rows = matrix.count, columns = matrix[0].count
    var dp:[Array] = [Array](repeating: [Int](repeating: 0, count: columns), count: rows)
    for i in 0 ..< rows {
        for j in 0 ..< columns {
            if matrix[i][j] == "1" {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1
                }
                maxSide = max(maxSide, dp[i][j])
            }
        }
    }
    return maxSide * maxSide
}
```


复杂度分析

- 时间复杂度：O(mn)，其中 m 和 n 是矩阵的行数和列数。需要遍历原始矩阵中的每个元素计算 dp 的值。
- 空间复杂度：O(mn)，其中 m 和 n 是矩阵的行数和列数。创建了一个和原始矩阵大小相同的矩阵 dp。由于状态转移方程中的 dp(i,j) 由其上方、左方和左上方的三个相邻位置的 dp 值决定，因此可以使用两个一维数组进行状态转移，空间复杂度优化至 O(n)。