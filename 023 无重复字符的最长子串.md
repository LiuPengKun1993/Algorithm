# 无重复字符的最长子串

> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。


示例1:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

#### 解题思路：

长度为 N 的字符串共有 (1+N)N/2个子字符串（复杂度为 O(N*N) ），判断长度为 N 的字符串是否有重复字符的复杂度为 O(N) ，因此本题使用暴力法解决的复杂度为 O(`N*N*N`) 。考虑使用动态规划降低时间复杂度。


#### 动态规划 + 线性遍历

左边界 i 获取方式： 遍历到 s[j] 时，初始化索引 i=j−1 ，向左遍历搜索第一个满足 s[i]=s[j] 的字符即可 。

```
public int lengthOfLongestSubstring(String s) {
    int res = 0, tmp = 0;
    for(int j = 0; j < s.length(); j++) {
        int i = j - 1;
        while(i >= 0 && s.charAt(i) != s.charAt(j)) i--; // 线性查找 i
        tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]
        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
    }
    return res;
}
```

复杂度分析

- 时间复杂度 O(N*N)。
- 空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。